module ReWire.Bits where

import ReWire

-- | "Cleared," "set."
--data Bit = C | S
data W8  = W8 Bit Bit Bit Bit Bit Bit Bit Bit
data W16 = W16 W8 W8
data W32 = W32 W16 W16
data W64 = W64 W32 W32

-- Bit operations

isSet :: Bit -> Bool
isSet S = True
isSet _ = False

toBit :: Bool -> Bit
toBit True = S
toBit _    = C

andb :: Bit -> Bit -> Bit
andb S S = S
andb _ _ = C

-- | addb x y ci = (x + y + ci, carry-out)
addb :: Bit -> Bit -> Bit -> (Bit, Bit)
addb x y ci = ((x `xorb` y) `xorb` ci, ((x `xorb` y) `andb` ci) `orb` (x `andb` y))

orb :: Bit -> Bit -> Bit
orb C C = C
orb _ _ = S

xorb :: Bit -> Bit -> Bit
xorb C C = C
xorb S S = C
xorb _ _ = S

notb :: Bit -> Bit
notb C = S
notb S = C

eqb :: Bit -> Bit -> Bool
eqb C C = True
eqb S S = True
eqb _ _ = False

-- W8 operations

zeroW8 :: W8
zeroW8 = W8 C C C C C C C C

oneW8 :: W8
oneW8 = W8 C C C C C C C S

onesW8 :: W8
onesW8 = W8 S S S S S S S S

isZeroW8 :: W8 -> Bool
isZeroW8 = eqW8 zeroW8

-- | Arithmetic mod 2^8 on nats. Increment.
incW8 :: W8 -> W8
incW8 = plusW8 oneW8

notW8 :: W8 -> W8
notW8 (W8 a b c d e f g h) = W8 (notb a) (notb b) (notb c) (notb d) (notb e) (notb f) (notb g) (notb h)

-- | Rotate left.
rolW8 :: W8 -> W8
rolW8 (W8 a b c d e f g h) = W8 b c d e f g h a

-- | Rotate right.
rorW8 :: W8 -> W8
rorW8 (W8 a b c d e f g h) = W8 h a b c d e f g

-- | Bitwise and.
andW8 :: W8 -> W8 -> W8
andW8 (W8 a  b  c  d  e  f  g  h )
      (W8 a' b' c' d' e' f' g' h') = W8 (andb a a') (andb b b') (andb c c') (andb d d') (andb e e') (andb f f') (andb g g') (andb h h')

-- | Bitwise or.
orW8 :: W8 -> W8 -> W8
orW8 (W8 a  b  c  d  e  f  g  h )
     (W8 a' b' c' d' e' f' g' h') = W8 (orb a a') (orb b b') (orb c c') (orb d d') (orb e e') (orb f f') (orb g g') (orb h h')

-- | Bitwise xor.
xorW8 :: W8 -> W8 -> W8
xorW8 (W8 a  b  c  d  e  f  g  h )
      (W8 a' b' c' d' e' f' g' h') = W8 (xorb a a') (xorb b b') (xorb c c') (xorb d d') (xorb e e') (xorb f f') (xorb g g') (xorb h h')

plusW8 :: W8 -> W8 -> W8
plusW8 x y = fst (plusW8' x y C)

-- | Ripple-carry adder.
plusW8' :: W8 -> W8 -> Bit -> (W8, Bit)
plusW8' (W8 a  b  c  d  e  f  g  h ) (W8 a' b' c' d' e' f' g' h') ci =
      let (r0, co0) = addb h h' ci
          (r1, co1) = addb g g' co0
          (r2, co2) = addb f f' co1
          (r3, co3) = addb e e' co2
          (r4, co4) = addb d d' co3
          (r5, co5) = addb c c' co4
          (r6, co6) = addb b b' co5
          (r7, co7) = addb a a' co6
      in (W8 r7 r6 r5 r4 r3 r2 r1 r0, co7)

eqW8 :: W8 -> W8 -> Bool
eqW8 (W8 a b c d e f g h) (W8 a' b' c' d' e' f' g' h')
      = a `eqb` a' && b `eqb` b'
     && c `eqb` c' && d `eqb` d'
     && e `eqb` e' && f `eqb` f'
     && g `eqb` g' && h `eqb` h'

-- W16 operations

zeroW16 :: W16
zeroW16 = W16 zeroW8 zeroW8

oneW16 :: W16
oneW16 = W16 zeroW8 oneW8

onesW16 :: W16
onesW16 = W16 onesW8 onesW8

isZeroW16 :: W16 -> Bool
isZeroW16 = eqW16 zeroW16

-- | Arithmetic mod 2^8 on nats. Increment.
incW16 :: W16 -> W16
incW16 = plusW16 oneW16

notW16 :: W16 -> W16
notW16 (W16 w1 w0) = W16 (notW8 w1) (notW8 w0)

-- | Bitwise and.
andW16 :: W16 -> W16 -> W16
andW16 (W16 w1 w0) (W16 w1' w0') = W16 (andW8 w1 w1') (andW8 w0 w0')

-- | Bitwise or.
orW16 :: W16 -> W16 -> W16
orW16 (W16 w1 w0) (W16 w1' w0') = W16 (orW8 w1 w1') (orW8 w0 w0')

-- | Bitwise xor.
xorW16 :: W16 -> W16 -> W16
xorW16 (W16 w1 w0) (W16 w1' w0') = W16 (xorW8 w1 w1') (xorW8 w0 w0')

plusW16 :: W16 -> W16 -> W16
plusW16 x y = fst (plusW16' x y C)

-- | Ripple-carry adder.
plusW16' :: W16 -> W16 -> Bit -> (W16, Bit)
plusW16' (W16 w1 w0) (W16 w1' w0') ci =
      let (r0, co0) = plusW8' w0 w0' ci
          (r1, co1) = plusW8' w1 w1' co0
      in (W16 r1 r0, co1)

eqW16 :: W16 -> W16 -> Bool
eqW16 (W16 w1 w0) (W16 w1' w0') = w1 `eqW8` w1' && w0 `eqW8` w0'

-- W32 operations

zeroW32 :: W32
zeroW32 = W32 zeroW16 zeroW16

oneW32 :: W32
oneW32 = W32 zeroW16 oneW16

onesW32 :: W32
onesW32 = W32 onesW16 onesW16

isZeroW32 :: W32 -> Bool
isZeroW32 = eqW32 zeroW32

-- | Arithmetic mod 2^8 on nats. Increment.
incW32 :: W32 -> W32
incW32 = plusW32 oneW32

notW32 :: W32 -> W32
notW32 (W32 w1 w0) = W32 (notW16 w1) (notW16 w0)

-- | Bitwise and.
andW32 :: W32 -> W32 -> W32
andW32 (W32 w1 w0) (W32 w1' w0') = W32 (andW16 w1 w1') (andW16 w0 w0')

-- | Bitwise or.
orW32 :: W32 -> W32 -> W32
orW32 (W32 w1 w0) (W32 w1' w0') = W32 (orW16 w1 w1') (orW16 w0 w0')

-- | Bitwise xor.
xorW32 :: W32 -> W32 -> W32
xorW32 (W32 w1 w0) (W32 w1' w0') = W32 (xorW16 w1 w1') (xorW16 w0 w0')

plusW32 :: W32 -> W32 -> W32
plusW32 x y = fst (plusW32' x y C)

-- | Ripple-carry adder.
plusW32' :: W32 -> W32 -> Bit -> (W32, Bit)
plusW32' (W32 w1 w0) (W32 w1' w0') ci =
      let (r0, co0) = plusW16' w0 w0' ci
          (r1, co1) = plusW16' w1 w1' co0
      in (W32 r1 r0, co1)

eqW32 :: W32 -> W32 -> Bool
eqW32 (W32 w1 w0) (W32 w1' w0') = w1 `eqW16` w1' && w0 `eqW16` w0'

-- W64 operations

zeroW64 :: W64
zeroW64 = W64 zeroW32 zeroW32

oneW64 :: W64
oneW64 = W64 zeroW32 oneW32

onesW64 :: W64
onesW64 = W64 onesW32 onesW32

isZeroW64 :: W64 -> Bool
isZeroW64 = eqW64 zeroW64

-- | Arithmetic mod 2^8 on nats. Increment.
incW64 :: W64 -> W64
incW64 = plusW64 oneW64

notW64 :: W64 -> W64
notW64 (W64 w1 w0) = W64 (notW32 w1) (notW32 w0)

-- | Bitwise and.
andW64 :: W64 -> W64 -> W64
andW64 (W64 w1 w0) (W64 w1' w0') = W64 (andW32 w1 w1') (andW32 w0 w0')

-- | Bitwise or.
orW64 :: W64 -> W64 -> W64
orW64 (W64 w1 w0) (W64 w1' w0') = W64 (orW32 w1 w1') (orW32 w0 w0')

-- | Bitwise xor.
xorW64 :: W64 -> W64 -> W64
xorW64 (W64 w1 w0) (W64 w1' w0') = W64 (xorW32 w1 w1') (xorW32 w0 w0')

plusW64 :: W64 -> W64 -> W64
plusW64 x y = fst (plusW64' x y C)

-- | Ripple-carry adder.
plusW64' :: W64 -> W64 -> Bit -> (W64, Bit)
plusW64' (W64 w1 w0) (W64 w1' w0') ci =
      let (r0, co0) = plusW32' w0 w0' ci
          (r1, co1) = plusW32' w1 w1' co0
      in (W64 r1 r0, co1)

eqW64 :: W64 -> W64 -> Bool
eqW64 (W64 w1 w0) (W64 w1' w0') = w1 `eqW32` w1' && w0 `eqW32` w0'
